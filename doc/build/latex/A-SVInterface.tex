%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional\else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage[dontkeepoldnames]{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{A-SV Interface Documentation}
\date{Sep 19, 2017}
\release{2.0}
\author{bp, st \& wy}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{Abaqus Scripting User’s Guide}
\label{\detokenize{abq_script_guide:welcome-to-a-sv-interface-s-documentation}}\label{\detokenize{abq_script_guide::doc}}\label{\detokenize{abq_script_guide:abaqus-scripting-user-s-guide}}

\section{5 Using Python and the Abaqus Scripting Interface}
\label{\detokenize{abq_script_guide:using-python-and-the-abaqus-scripting-interface}}

\subsection{5.6 Extending the Abaqus Scripting Interface}
\label{\detokenize{abq_script_guide:extending-the-abaqus-scripting-interface}}
You can extend the functionality of the Abaqus Scripting Interface by writing your own modules that contain classes and functions to accomplish tasks that are not directly available in Abaqus. For example, you can write a function to print the names of all materials that have a density specified, or you can write a function that creates a contour plot using a custom set of contour plot options. Creating functions and modules in Python is described in “Creating functions,” Section 4.6.1, and “Functions and modules,” Section 4.6.5.

This section describes how you can extend the functionality of the Abaqus Scripting Interface. The following topics are covered:
\begin{itemize}
\item {} 
“Storing custom data in the model database or in other objects,” Section 5.6.1

\item {} 
“Interaction with the GUI,” Section 5.6.2

\item {} 
“CommandRegister class,” Section 5.6.3

\item {} 
“Repositories,” Section 5.6.4

\item {} 
“Repository methods,” Section 5.6.5

\item {} 
“RepositorySupport,” Section 5.6.6

\item {} 
“Registered dictionaries,” Section 5.6.7

\item {} 
“Registered lists,” Section 5.6.8

\item {} 
“Registered tuples,” Section 5.6.9

\item {} 
“Session data,” Section 5.6.10

\item {} 
“Saving application data in a model database,” Section 5.6.11

\item {} 
“Checking a model database when it is opened,” Section 5.6.12

\end{itemize}


\subsubsection{5.6.1 Storing custom data in the model database or in other objects}
\label{\detokenize{abq_script_guide:storing-custom-data-in-the-model-database-or-in-other-objects}}
If you extend the kernel functionality by writing your own classes and functions, you may want to store data required by those classes or functions in the Abaqus/CAE model database so the data are available the next time you open the database. To store custom kernel data in the Abaqus/CAE model database, you must make use of the \sphinxcode{customKernel} module. The \sphinxcode{customKernel} module augments the mdb object with a member called \sphinxstyleemphasis{customData}. When you save a model database, Abaqus/CAE also saves any data created below the customData object.

For example,

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{customKernel}
\PYG{n}{mdb} \PYG{o}{=} \PYG{n}{Mdb}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{myString} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The width is }\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{myNumber} \PYG{o}{=} \PYG{l+m+mi}{58}
\PYG{n}{mdb}\PYG{o}{.}\PYG{n}{saveAs}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{custom\PYGZhy{}test.cae}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{mdb}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

If you start a new session and open the model database, \sphinxcode{custom-test.cae}, you can refer to the variables that you saved. For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{customKernel}
\PYG{g+go}{mdb = openMdb(\PYGZsq{}custom\PYGZhy{}test.cae\PYGZsq{})}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{myString}\PYG{p}{,} \PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{myNumber}
\PYG{g+go}{The width is 58}
\end{sphinxVerbatim}

You can store almost any type of Python object under \sphinxcode{mdb.customData}; for example, strings, numbers, and Python classes. However, there are some restrictions; for example, you cannot store file objects. These restrictions are due to the fact that the Abaqus/CAE infrastructure uses Python’s \sphinxcode{pickle} module to store the \sphinxstyleemphasis{customData} object in the model database. The \sphinxcode{pickle} module allows the Python programmer to write a data structure to a file and then recreate that data structure when reading from the file. For details on the restrictions imposed by the \sphinxcode{pickle} module, see the official Python web site (www.python.org).

If your code creates a custom class and stores an instance of the class in the model database, the custom module that defined that custom class must be available for Python to unpickle the data when the database is subsequently opened. Consequently, if a user saves custom data to a model database and then passes that model database to another user, the other user must also have access to the custom modules that produced the custom data. Otherwise, they will not be able to load the custom data into their Abaqus/CAE session.

Abaqus/CAE does not keep track of changes made to the \sphinxstyleemphasis{customData} object. As a result, when the user quits a session, Abaqus/CAE will not prompt them to save their changes if they changed only objects under \sphinxstyleemphasis{customData}.


\subsubsection{5.6.2 Interaction with the GUI}
\label{\detokenize{abq_script_guide:interaction-with-the-gui}}
In addition to providing a persistence mechanism, the \sphinxcode{customKernel} module contains classes that provide the following capabilities:
\begin{itemize}
\item {} 
Querying custom kernel data values from the GUI. From a GUI script you can access some attribute of your custom kernel object, just as you would from the kernel. For example,

\sphinxcode{print mdb.customData.myObject.name}

\item {} 
Notification to the GUI when custom kernel data change. For example, you can have a manager dialog box that lists the objects in a repository. When the contents of the repository change, you can be notified and take the appropriate action to update the list of objects in the manager dialog box.

\end{itemize}

To make use of these features, you must derive your custom kernel objects from the classes listed in the following sections. For more details on GUI customization, see the Abaqus GUI Toolkit Reference Guide.


\subsubsection{5.6.3 CommandRegister class}
\label{\detokenize{abq_script_guide:commandregister-class}}
You can use the CommandRegister class to derive a general class that can be queried from the GUI. In addition, the class can notify the GUI when its contents change. For example,

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Block}\PYG{p}{(}\PYG{n}{CommandRegister}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{name}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{CommandRegister}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

If a query is registered by the GUI on an instance of this class, the GUI will be notified when a member of this instance is changed, added, or deleted, For more details on registering queries, see the Abaqus GUI Toolkit Reference Guide.

If your object is to be stored in a repository (see below), the first argument to the constructor must be a string representing the name of the object. That string will automatically be assigned by the infrastructure to a member called \sphinxstyleemphasis{name}.


\subsubsection{5.6.4 Repositories}
\label{\detokenize{abq_script_guide:repositories}}
Repositories are containers that hold objects that are keyed by strings. It may be convenient to store your custom kernel objects in repositories, in the same way that Abaqus/CAE part objects are stored in the \sphinxcode{Parts} repository.

The customData object is an instance of a \sphinxcode{RepositorySupport} class, which provides a \sphinxcode{Repository} method that allows you to create a repository as an attribute of the instance. For more information, see “RepositorySupport,” Section 5.6.6. The arguments to the \sphinxcode{Repository} method are the name of the repository and a constructor or a sequence of constructors. Those constructors must have \sphinxstyleemphasis{name} as their first argument, and the infrastructure will automatically assign that value to a member called \sphinxstyleemphasis{name}. Instances of these constructors will be stored in the repository. For more information, see “Repository object,” Section 53.3 of the Abaqus Scripting Reference Guide.

Since repositories are designed to notify the GUI when their contents change, the objects placed inside them should be derived from either \sphinxcode{CommandRegister} or \sphinxcode{RepositorySupport} to extend this capability to its fullest.

The Abaqus Scripting Interface uses the following conventions:
\begin{itemize}
\item {} 
The name of a repository is a plural noun with all lowercase letters.

\item {} 
A constructor is a capitalized noun (or a combination of capitalized nouns and adjectives).

\item {} 
The first argument to the constructor must be \sphinxstyleemphasis{name}.

\end{itemize}

For example, the \sphinxcode{Part} constructor creates a part object and stores it in the \sphinxcode{parts} repository. You can access the part object from the repository using the same name argument that you passed in with the \sphinxcode{Part} constructor. In some cases, more than one constructor can create instances that are stored in the same repository. For example, the \sphinxcode{HomogeneousSolidSection} and the \sphinxcode{HomogeneousShellSection} constructors both create section objects that are stored in the \sphinxcode{sections} repository. For more information, see “Abstract base type,” Section 6.1.5. For example, the following script creates a \sphinxcode{blocks} repository, and the \sphinxcode{Block} constructor creates a block object in the \sphinxcode{blocks} repository:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{customKernel} \PYG{k+kn}{import} \PYG{n}{CommandRegister}
\PYG{k}{class} \PYG{n+nc}{Block}\PYG{p}{(}\PYG{n}{CommandRegister}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{name}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{CommandRegister}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}

\PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{Repository}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blocks}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{Block}\PYG{p}{)}
\PYG{n}{block} \PYG{o}{=} \PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{Block}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Block\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{blocks}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Block\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{name} \PYG{n}{Block}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}


\subsubsection{5.6.5 Repository methods}
\label{\detokenize{abq_script_guide:repository-methods}}
Repositories have several useful methods for querying their contents, as shown in the following table:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Method
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Description
\unskip}\relax \\
\hline
keys()
&
Returns a list of the keys in the repository.
\\
\hline
has\_key()
&
Returns 1 if the key is found in the repository; otherwise, returns 0.
\\
\hline
values()
&
Returns a list of the objects in the repository.
\\
\hline
items()
&
Returns a list of key, value pairs in the repository.
\\
\hline
changeKey(fromName, toName)
&
Changes the name of a key in the repository. This method will also change the name attribute of the instance in the repository.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The following script illustrates some of these methods:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{customKernel}
\PYG{k+kn}{import} \PYG{n+nn}{CommandRegister}
\PYG{k}{class} \PYG{n+nc}{Block}\PYG{p}{(}\PYG{n}{CommandRegister}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{name}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{CommandRegister}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}

\PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{Repository}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blocks}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{Block}\PYG{p}{)}
\PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{Block}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Block\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{Block}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Block\PYGZhy{}2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The original repository keys are: }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
  \PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{blocks}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{blocks}\PYG{o}{.}\PYG{n}{has\PYGZus{}key}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Block\PYGZhy{}2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{blocks}\PYG{o}{.}\PYG{n}{has\PYGZus{}key}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Block\PYGZhy{}3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{blocks}\PYG{o}{.}\PYG{n}{changeKey}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Block\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Block\PYGZhy{}11}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The modified repository keys are: }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
  \PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{blocks}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The name member is }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
  \PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{blocks}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Block\PYGZhy{}11}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{name}
\PYG{k}{print} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The repository size is}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{blocks}\PYG{p}{)}
\end{sphinxVerbatim}

The resulting output is

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
The original repository keys are [\PYGZsq{}Block\PYGZhy{}1\PYGZsq{}, \PYGZsq{}Block\PYGZhy{}2\PYGZsq{}]
1
0
The modified repository keys are [\PYGZsq{}Block\PYGZhy{}11\PYGZsq{}, \PYGZsq{}Block\PYGZhy{}2\PYGZsq{}]
The name member is Block\PYGZhy{}11
The repository size is 2
\end{sphinxVerbatim}


\subsubsection{5.6.6 RepositorySupport}
\label{\detokenize{abq_script_guide:repositorysupport}}
You can use the \sphinxcode{RepositorySupport} class to derive a class that can contain one or more repositories. However, if you do not intend to create a repository as an attribute of your class, you should derive your class from \sphinxcode{CommandRegister}, not from \sphinxcode{RepositorySupport}.

Using the \sphinxcode{RepositorySupport} class allows you to create a hierarchy of repositories; for example, in the Abaqus Scripting Interface the \sphinxcode{parts} repository is a child of the \sphinxcode{models} repository. The first argument passed into your constructor is stored as \sphinxstyleemphasis{name}; it is created automatically by the infrastructure. To create a hierarchy of repositories, derive your class from \sphinxcode{RepositorySupport} and use its \sphinxcode{Repository} method to create child repositories as shown below. The \sphinxcode{Repository} method is described in “Repositories,” Section 5.6.4.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{abaqus} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{from} \PYG{n+nn}{customKernel} \PYG{k+kn}{import} \PYG{n}{CommandRegister}\PYG{p}{,} \PYG{n}{RepositorySupport}
\PYG{k}{class} \PYG{n+nc}{Block}\PYG{p}{(}\PYG{n}{CommandRegister}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{name}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{CommandRegister}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}

\PYG{k}{class} \PYG{n+nc}{Model}\PYG{p}{(}\PYG{n}{RepositorySupport}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{name}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{RepositorySupport}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}
      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{Repository}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blocks}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{Block}\PYG{p}{)}

\PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{Repository}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{models}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{Model}\PYG{p}{)}
\PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{Model}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Model\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{models}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Model\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{Block}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Block\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

The path to the object being created can be found by calling \sphinxcode{repr(self)} in the constructor of your object.


\subsubsection{5.6.7 Registered dictionaries}
\label{\detokenize{abq_script_guide:registered-dictionaries}}
You use the \sphinxcode{RegisteredDictionary} class to create a dictionary that can be queried from the GUI. In addition, the infrastructure can notify the GUI when the contents of the dictionary change. The key of a registered dictionary must be either a String or an Int. The values associated with a key must all be of the same type—all integers or all strings, for example—to prevent errors when accessing them from the GUI. The \sphinxcode{RegisteredDictionary} class has the same methods as a Python dictionary. In addition, the \sphinxcode{RegisteredDictionary} class has a \sphinxcode{changeKey} method that you use to rename a key in the dictionary. For example,

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{customKernel} \PYG{k+kn}{import} \PYG{n}{RegisteredDictionary}
\PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{myDictionary} \PYG{o}{=} \PYG{n}{RegisteredDictionary}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{myDictionary}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Key\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{myDictionary}\PYG{o}{.}\PYG{n}{changeKey}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Key\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Key\PYGZhy{}2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{5.6.8 Registered lists}
\label{\detokenize{abq_script_guide:registered-lists}}
You use the \sphinxcode{RegisteredList} class to create a list that can be queried from the GUI. In addition, the infrastructure can notify the GUI when the contents of the list change. The values in the list must all be of the same type—all integers or all strings, for example—to prevent errors when accessing them from the GUI. The values must all be of the same type; for example, all integers or all strings. The \sphinxcode{RegisteredList} has the same methods as a Python list. For example, appending \sphinxcode{Item-1} to the list in the following statements causes the infrastructure to notify the GUI that the contents of the list have changed:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{customKernel} \PYG{k+kn}{import} \PYG{n}{RegisteredList}
\PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{myList} \PYG{o}{=} \PYG{n}{RegisteredList}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{myList}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Item\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{5.6.9 Registered tuples}
\label{\detokenize{abq_script_guide:registered-tuples}}
You use the \sphinxcode{RegisteredTuple} class to create a tuple that can be queried from the GUI. In addition, the infrastructure can notify the GUI when the contents of any of the members of the tuple change. The members in the tuple must derive from the \sphinxcode{CommandRegister} class, and the values in the tuple must all be of the same type; for example, all integers or all strings. For example,

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{abaqus} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{from} \PYG{n+nn}{customKernel} \PYG{k+kn}{import} \PYG{n}{CommandRegister}\PYG{p}{,} \PYG{n}{RegisteredTuple}
\PYG{k}{class} \PYG{n+nc}{Block}\PYG{p}{(}\PYG{n}{CommandRegister}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{name}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{CommandRegister}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}

\PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{Repository}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blocks}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{Block}\PYG{p}{)}
\PYG{n}{block1} \PYG{o}{=} \PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{Block}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Block\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{block2} \PYG{o}{=} \PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{Block}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Block\PYGZhy{}2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{tuple} \PYG{o}{=} \PYG{p}{(}\PYG{n}{block1}\PYG{p}{,} \PYG{n}{block2}\PYG{p}{)}
\PYG{n}{mdb}\PYG{o}{.}\PYG{n}{customData}\PYG{o}{.}\PYG{n}{myTuple} \PYG{o}{=} \PYG{n}{RegisteredTuple}\PYG{p}{(}\PYG{n+nb}{tuple}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{5.6.10 Session data}
\label{\detokenize{abq_script_guide:session-data}}
The \sphinxcode{customKernel} module also provides a session.customData object that allows you to store data on the session object and query it from the GUI. Data stored on the session object persist only for the current Abaqus/CAE session. When you close the Abaqus/CAE session, Abaqus does not store any of the data below \sphinxcode{session.customData} on the model database. As a result, these data will be lost, and you will not be able to retrieve these data when you start a new session and open the model database. The session object is useful for maintaining data relevant to the current session only, such as the current model or output database.

The same methods and classes that are available for \sphinxcode{mdb.customData} are available for \sphinxcode{session.customData}.


\subsubsection{5.6.11 Saving application data in a model database}
\label{\detokenize{abq_script_guide:saving-application-data-in-a-model-database}}
If you have custom kernel scripts that store data in a model database, you may want to store information about your application in the same model database. When the model database is opened subsequently, you can access this information and decide how to proceed. For example, you can store version information and check if you need to upgrade your data in the model database.

You use the appData object to store custom application-related data in the model database. The appData object is an instance of an AbaqusAppData class. You can add any attributes to the appData object that are necessary to track information about your custom application. The following example illustrates how you can store the version number of your application on the appData object:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{customKernel}
\PYG{n}{myAppData} \PYG{o}{=} \PYG{n}{customKernel}\PYG{o}{.}\PYG{n}{AbaqusAppData}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{myAppData}\PYG{o}{.}\PYG{n}{majorVersion} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{myAppData}\PYG{o}{.}\PYG{n}{minorVersion} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{myAppData}\PYG{o}{.}\PYG{n}{updateVersion} \PYG{o}{=} \PYG{l+m+mi}{3}
\end{sphinxVerbatim}

You use the \sphinxcode{setAppData} method to install an appData object as session.customData.appData and to associate it with your application name. For example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
myAppName = ‘My App’
customKernel.setAppData(myAppName, myAppData)
\end{sphinxVerbatim}

You can call the \sphinxcode{setAppData} method only once per application name, which prevents unauthorized changes to the method. However, the \sphinxcode{setAppData} method may be called multiple times using different application names to allow more than one application to register with the same model database.
When the user saves a model database, Abaqus copies the session.customData.appData object to the mdb.customData.appData object.


\subsubsection{5.6.12 Checking a model database when it is opened}
\label{\detokenize{abq_script_guide:checking-a-model-database-when-it-is-opened}}
If you have custom kernel scripts that use custom data in a model database, you may want your application to verify some of the contents of a model database before it is fully opened. For example, you may want to check the database to see if you need to upgrade the data that is stored in it. In addition, you may need to initialize a new model database with your custom data. Two methods are provided for verifying and initializing a model database: \sphinxcode{verifyMdb} and \sphinxcode{initializeMdb}.

\sphinxstylestrong{Verifying a model database}

The \sphinxcode{verifyMdb} method is used to verify the partial contents of a model database when it is opened. You must write the \sphinxcode{verifyMdb} method and install it using the \sphinxcode{setVerifyMdb} method. You can call the \sphinxcode{setVerifyMdb} method only once per application name, which prevents unauthorized changes to the method. However, the \sphinxcode{setVerifyMdb} method may be called multiple times using different application names to allow more than one application to register with the same model database.

When Abaqus opens a model database, its first action is to load only the mdb.customData.appData object and pass that object to each \sphinxcode{verifyMdb} method registered in the session. If the model database has no appData, then Abaqus passes \sphinxcode{None} to each \sphinxcode{verifyMdb} method. Inside your \sphinxcode{verifyMdb} method you can query the appData object to determine if you need to take any action, such as upgrading your data.

\sphinxstylestrong{Initializing a model database}

If a script creates a new model database, you can initialize the model database with your custom objects using the \sphinxcode{initializeMdb} method. Abaqus calls each \sphinxcode{initializeMdb} method registered with the session whenever a new model database is created. You must write the \sphinxcode{initializeMdb} method and install it using the \sphinxcode{setInitializeMdb} method. You can call the \sphinxcode{setInitializeMdb} method only once per application name, which prevents unauthorized changes to the method. However, the \sphinxcode{setInitializeMdb} method may be called multiple times using different application names to allow more than one application to register with the same model database.

Kernel initialization scripts specified by the \sphinxstylestrong{startup} command line option are executed by Abaqus/CAE after it has finished its initialization process. By that time, a new model database or a database specified on the command line using the \sphinxstylestrong{database} option has already been opened. A utility method called \sphinxcode{processInitialMdb} has been created to automatically process the initial model database for you. If the initial model database does not have any \sphinxstyleemphasis{customData} or does not have \sphinxstyleemphasis{customData} for your particular application, your \sphinxcode{initializeMdb} method will be called. If the initial model database has \sphinxstyleemphasis{customData} for your application, your \sphinxcode{verifyMdb} method will be called.

The following example shows how you can use the \sphinxcode{verifyMdb}, \sphinxcode{intializeMdb}, and \sphinxcode{processInitialMdb} methods. You should execute the example using the \sphinxstylestrong{startup} command line option when you start Abaqus/CAE. For more information, see “Abaqus/CAE execution,” Section 3.2.6 of the Abaqus Analysis User’s Guide.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{abaqus} \PYG{k+kn}{import} \PYG{n}{mdb}\PYG{p}{,} \PYG{n}{session}
\PYG{k+kn}{import} \PYG{n+nn}{customKernel}
\PYG{n}{myAppName} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{My App}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{myAppData} \PYG{o}{=} \PYG{n}{customKernel}\PYG{o}{.}\PYG{n}{AbaqusAppData}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{myAppData}\PYG{o}{.}\PYG{n}{majorVersion} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{myAppData}\PYG{o}{.}\PYG{n}{minorVersion} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{myAppData}\PYG{o}{.}\PYG{n}{updateVersion} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{customKernel}\PYG{o}{.}\PYG{n}{setAppData}\PYG{p}{(}\PYG{n}{myAppName}\PYG{p}{,} \PYG{n}{myAppData}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}}
\PYG{k}{def} \PYG{n+nf}{verifyMdb}\PYG{p}{(}\PYG{n}{mdbAppData}\PYG{p}{)}\PYG{p}{:}
  \PYG{c+c1}{\PYGZsh{} If there is no appData, initialize the MDB.}
  \PYG{c+c1}{\PYGZsh{}}
  \PYG{k}{if} \PYG{n}{mdbAppData}\PYG{o}{==}\PYG{n+nb+bp}{None}\PYG{p}{:}
    \PYG{n}{initializeMdb}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{return}
  \PYG{c+c1}{\PYGZsh{} If my application is not in appData, initialize the MDB.}
  \PYG{c+c1}{\PYGZsh{}}
  \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{mdbAppData}\PYG{o}{.}\PYG{n}{has\PYGZus{}key}\PYG{p}{(}\PYG{n}{myAppName}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{initializeMdb}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{return}

  \PYG{c+c1}{\PYGZsh{} Perform any checks on the appData or customData here}

\PYG{c+c1}{\PYGZsh{} Set the verifyMdb method for the application.}
\PYG{c+c1}{\PYGZsh{} setVerifyMdb may be called only once per application name.}
\PYG{c+c1}{\PYGZsh{}}
\PYG{n}{customKernel}\PYG{o}{.}\PYG{n}{setVerifyMdb}\PYG{p}{(}\PYG{n}{myAppName}\PYG{p}{,} \PYG{n}{verifyMdb}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}}
\PYG{k}{def} \PYG{n+nf}{initializeMdb}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
  \PYG{c+c1}{\PYGZsh{} Initialize the MDB here}


\PYG{c+c1}{\PYGZsh{} Set the initializeMdb method for this application.}
\PYG{c+c1}{\PYGZsh{} setInitializeMdb may be called only once per application name.}
\PYG{c+c1}{\PYGZsh{}}
\PYG{n}{customKernel}\PYG{o}{.}\PYG{n}{setInitializeMdb}\PYG{p}{(}\PYG{n}{myAppName}\PYG{p}{,} \PYG{n}{initializeMdb}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} This file is executed after Abaqus/CAE has started, so we need to}
\PYG{c+c1}{\PYGZsh{} process the initial MDB (either a new, empty MDB created by Abaqus/CAE,}
\PYG{c+c1}{\PYGZsh{} or a database opened via the \PYGZhy{}database command line argument).}
\PYG{c+c1}{\PYGZsh{}}
\PYG{n}{customKernel}\PYG{o}{.}\PYG{n}{processInitialMdb}\PYG{p}{(}\PYG{n}{myAppName}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}